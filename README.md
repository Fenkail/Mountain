# Mountain

## c++程序基础
### 源代码与规范性
- 头文件h与源文件c的区别和形成原因
    - 头文件多为一些声明和抽象，其实也可以部分
    - 每个文件（或者其他语言）独立编译，编译前需要声明，可以避免一些重复
    - 只展示h的接口，可以用于保护源程序
- 规范性
    - Google和 geosoft，每次简单阅读一分钟即可

### 基本结构
略
### 命名空间
略
### 编译流程
>源代码-->编译器-->机器码-->链接器-->可执行代码
- 编译器
    - 首先进行预编译，代码文本替换之类的
- 链接器
    - 多个编译器生成的目标文件+库文件进行连接，解析符号的引用，目标文件中`占位符`替换为`地址符号`  
- 动态链接库与静态连接库
    - 静态链接库
        - 代码直接进入目标程序，`exe`时候不需要其他
    - 动态链接库
        -   DLL(dynamic link library),调用函数所在的DLL，只链接一些位置信息，实际运行时再去dll进行寻找。

### 常见错误
略


## 语法增强
### 引用
引用相当于别名，外号；一个人可以有多个外号，但是一个外号只对应一个人
### 性质
1. 通过引用进行的读写操作，实际会作用于原始变量。（类似于Python中直接对变量进行操作，也有点深拷贝和浅拷贝的感觉）；
2. 引用必须进行初始化；
3. 引用初始化后不能再指定其他的变量；
4. 被调函数改变引用变量的值，则改变实际值
### 习题
交换变量
1. 形参
2. 取地址
3. 引用
## 空指针与动态内存分配
### 空指针
- cpp03中，`0`代表常量空指针
- c语言中用(void *)0表示
- CPP11中，`nullptr`作为空指针
### 动态内存
- new申请动态内存，成功返回地址；失败返回空指针
- delete进行内存释放 (java中有垃圾回收机制，实际有坑)
> new  <类型名> (初值) ;     //申请一个变量的空间

> new  <类型名>[常量表达式] ;   //申请数组

### 布尔类型
- 具体所占空间由编译器决定，g++实测为1byte
- `风格`：布尔类型的命名建议为 `is_Name`

### 初始化
两种方式，使用第二种更好，当赋值不合适时，编译器报错：
1. int x = 0;
2. int x {0};
### 数据类型转换
涉及数据类型转换时，建议显示转换：
1. const_cast     去除变量的const/volatile
2.  reinterpret_cast    任意指针/引用类型之间的转换， 指针与整数之间
3. static_cast    常用类型转化
4. dynamic_cast    基类的引用+指针   转化 派生类引用+指针

### c++11 类型系统的增强
1. 目的：  定义不同程序之间的接口   检查可接性
2. auto：
    - 必须初始化
    - 会去除&和const，如果需要使用`auto&`成为同内存地址的引用
    - 数组类型，`auto`为指针  `auto&`为引用
    - 可尽量多使用，保证程序的健壮`auto m = int {3}`  `auto m = 42.f`
3. decltype
    编译时触发、不需要初始化、多用于对函数返回的类型推导


### c++内存模型
>常量区--全局/静态区--堆(->)--栈（<-）
1. 常量区
    - 声明后不能修改，只读部分，修改可能导致程序崩溃
    - 所有常亮都在这里，常亮不可变
    - `str = "qwert"` qwert为常量区
    - 字面常量和命名常量
    - **规范**：常量必须使用大写字母，并用下划线分割单词 `COLOR_RED`
2. 全局/静态区
    - 一般于主函数之前，程序运行开始，结束即释放
3. 堆
    - 程序员进行分配释放或者OS进行释放
    - （new/delete）
4. 栈
    - 编译器进行自动分配与释放
    - `str = "qwert"` qwert为常量区   `str`或者函数中的形式参数

### 指针
指针是一个地址，一般情况下64位的机器地址为0x???？共12个16进制的数，相当于48位。 X86_64位处理器地址线只有48条（64-48）的剩余地址必须与第48保持一致，从而导致了当前的情况。
- 指针变量：指针放到变量中。
- 指针常量：指针放到常量中。
- 常量指针：指针指向常亮。 
- *与const：
    1. 谁在前谁先读
    2. const在谁前，谁不变
    3. *表示数据，名字表示地址


### typedef和#define
1. #define是定义一种宏（macro），编译器不检查，无分号
2. typedef 形成一种新的类型名，之后用using更加直观，可定义模板

### 特殊函数
1. 变量作用域
    - 使用`::`可以调用全局变量进行处理
2. 重载
    - 由编译器决定
    - 若有默认值，右侧，不允许定义默认参数
    - 函数名，参数，参数类型  与 函数名类型无关
3. 内联inline
    - 代码直插，优化控制，提升性能
    - 具体是否开展由编译器决定
4. for的范围函数
    - for(auto &i : a){}
    - const的i不修改原数组值
    - 引用修改原值

## 对象和类基础
### 基础
1. 类
    - 一个对象表示现实中一个实体（唯一标识、状态（数据变量）、行为）
    - 抽象、多态、继承、封装
2. 对象 object
    - 类的实例
3. 构造函数
    - 自动创建、与类同名、void、不带参数
    - `C c1 {};`的形式有利于编译器检查
### 对象拷贝和匿名对象
类也是一种数据类型，相当于`int`、`double`
1. 直接初始化和拷贝列表初始化
    - `C c3 {2.3}；`直接初始化
    - `C c4 = {4.5}`拷贝
2. struct与class
    - 基本相同
    - struct默认public；class默认private
3. 具体详见代码
### 声明与分离
1. `#include <>  ""` 尖括号系统，引号自定义
2. 通常来说，类的声明于.h，实现于.cpp;main中只要包含.h的声明即可，但是本次实验中，main中只有仅仅包含.cpp运行正确。main同时包含声明和实现重复定义，只包含声明报错未定义。
3. 头文件只编译一次`_Pragma("Once")`
4. cpp中一些对象和创建和传值操作
### 字符串与array
1. 字符串基本等同于Python、JAVA
2. Array
    - 容器类：包含迭代器，高级指针
    - 模板类：可容纳任何数据
    - `std::array <类型，大小>名字`
## 对象和类高级
Unit5，内容多，时间紧，提速
### 常量表达式
1. consrexpr 编译期间即可计算结果--》提升代码执行的性能
2. const 即可以声明编译期间常量，也可以声明运行期间常量
3. constexpr即使声明后，代码也不一定完全在编译期间执行计算
### 断言
1. 若为真，通过；通常表述某些用不能发生的事情
2. 代码分为调试模式和发型模式，在发行模式assert不起作用，除非进行声明
### 声明与定义
1. 声明：描述某些类型，compiler使用 `class A {};`
2. 定义：实例化某标识符，linker使用 `class A;`
### 代理构造
类中一个套一个进行委托构造，避免环形
### 不可变对象和类
对象确立后，其内容不可变，除非通过成员进行拷贝（Data类，后续通过setYear进行修改）
### 实例与静态成员
非静态成员，无法直接使用类名去调用。使用变量都是可以的
### 析构函数（dtor）
对象销毁时自动调用，参数可为空，无法重载
### 友元函数
解决私有成员无法从外部访问的问题，通过`friend void print（const Data& d）`的方式访问私有成员
### 深浅拷贝
深拷贝拷贝内容，浅拷贝拷贝地址
### vector
容量大小可变
`vector <int> name {};`
- 风格：变量名使用i，j，k。j和k只用于嵌套
### 风格
1. 变量在其声明时初始化
2. 运算符前后空格，CPP关键字后空格，冒号前后空格，for语句分好后空格

## 继承和构造
### 概念
1. 多重子类的共有属性可以抽象为父类
2. final 关键字阻止继承
3. 习题，继承练习
### 多态
对于不同类型的实体/对象 有这不同的响应-->OOP多态
1. 重载多态
2. 子类多态
3. Binding 联编，确定多态的调用过程
4. 虚函数与override