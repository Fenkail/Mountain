# Mountain

## c++程序基础
### 源代码与规范性
- 头文件h与源文件c的区别和形成原因
    - 头文件多为一些声明和抽象，其实也可以部分
    - 每个文件（或者其他语言）独立编译，编译前需要声明，可以避免一些重复
    - 只展示h的接口，可以用于保护源程序
- 规范性
    - Google和 geosoft，每次简单阅读一分钟即可

### 基本结构
略
### 命名空间
略
### 编译流程
>源代码-->编译器-->机器码-->链接器-->可执行代码
- 编译器
    - 首先进行预编译，代码文本替换之类的
- 链接器
    - 多个编译器生成的目标文件+库文件进行连接，解析符号的引用，目标文件中`占位符`替换为`地址符号`  
- 动态链接库与静态连接库
    - 静态链接库
        - 代码直接进入目标程序，`exe`时候不需要其他
    - 动态链接库
        -   DLL(dynamic link library),调用函数所在的DLL，只链接一些位置信息，实际运行时再去dll进行寻找。

### 常见错误
略


# 语法增强
## 引用
引用相当于别名，外号；一个人可以有多个外号，但是一个外号只对应一个人
### 性质
1. 通过引用进行的读写操作，实际会作用于原始变量。（类似于Python中直接对变量进行操作，也有点深拷贝和浅拷贝的感觉）；
2. 引用必须进行初始化；
3. 引用初始化后不能再指定其他的变量；
4. 被调函数改变引用变量的值，则改变实际值
### 习题
交换变量
1. 形参
2. 取地址
3. 引用
## 空指针与动态内存分配
### 空指针
- cpp03中，`0`代表常量空指针
- c语言中用(void *)0表示
- CPP11中，`nullptr`作为空指针
### 动态内存
- new申请动态内存，成功返回地址；失败返回空指针
- delete进行内存释放 (java中有垃圾回收机制，实际有坑)
> new  <类型名> (初值) ;     //申请一个变量的空间

> new  <类型名>[常量表达式] ;   //申请数组

### 布尔类型
- 具体所占空间由编译器决定，g++实测为1byte
- `风格`：布尔类型的命名建议为 `is_Name`

### 初始化
两种方式，使用第二种更好，当赋值不合适时，编译器报错：
1. int x = 0;
2. int x {0};
### 数据类型转换
涉及数据类型转换时，建议显示转换：
1. const_cast     去除变量的const/volatile
2.  reinterpret_cast    任意指针/引用类型之间的转换， 指针与整数之间
3. static_cast    常用类型转化
4. dynamic_cast    基类的引用+指针   转化 派生类引用+指针

### c++11 类型系统的增强
1. 目的：  定义不同程序之间的接口   检查可接性
2. auto：
    - 必须初始化
    - 会去除&和const，如果需要使用`auto&`成为同内存地址的引用
    - 数组类型，`auto`为指针  `auto&`为引用
    - 可尽量多使用，保证程序的健壮`auto m = int {3}`  `auto m = 42.f`
3. decltype
    编译时触发、不需要初始化、多用于对函数返回的类型推导